# ä»Žä¼—å¿ƒç†æ—¶é—´åˆ†æžç®—æ³•è¯¦è§£

## ðŸ“‹ æ¦‚è¿°

ä»Žä¼—å¿ƒç†æ—¶é—´åˆ†æžæ¨¡å— (`conformity_time_analyzer.py`) æ˜¯ä¸“é—¨ç”¨äºŽåˆ†æžç¤¾äº¤åª’ä½“è¯„è®ºä¸­æ—¶é—´ä»Žä¼—å¿ƒç†ç‰¹å¾çš„ç®—æ³•æ¨¡å—ã€‚è¯¥æ¨¡å—é€šè¿‡åˆ†æžå­è¯„è®ºä¸Žçˆ¶è¯„è®ºçš„æ—¶é—´é—´éš”ï¼Œé‡åŒ–ç”¨æˆ·çš„ä»Žä¼—å¿ƒç†å¼ºåº¦ï¼Œä¸ºç¤¾äº¤åª’ä½“è¡Œä¸ºåˆ†æžæä¾›ç§‘å­¦ä¾æ®ã€‚

## ðŸ§  ç®—æ³•åŽŸç†

### æ ¸å¿ƒæ€æƒ³
**æ—¶é—´ä»Žä¼—å¿ƒç†å‡è®¾**: ç”¨æˆ·åœ¨çœ‹åˆ°ä»–äººè¯„è®ºåŽï¼Œæ—¶é—´é—´éš”è¶ŠçŸ­ï¼Œä»Žä¼—å¿ƒç†è¶Šå¼ºã€‚é€šè¿‡é‡åŒ–è¿™ç§æ—¶é—´å…³ç³»ï¼Œå¯ä»¥è¯„ä¼°è¯„è®ºçš„ä»Žä¼—å¿ƒç†ç‰¹å¾ã€‚

### æ•°å­¦æ¨¡åž‹
```
ä»Žä¼—å¿ƒç†åˆ†æ•° = exp(-æ—¶é—´é—´éš” / è‡ªé€‚åº”è¡°å‡å› å­)
```

å…¶ä¸­ï¼š
- **æ—¶é—´é—´éš”**: å­è¯„è®ºä¸Žçˆ¶è¯„è®ºçš„æ—¶é—´å·®ï¼ˆç§’ï¼‰
- **è‡ªé€‚åº”è¡°å‡å› å­**: æ ¹æ®æ•°æ®ç‰¹å¾åŠ¨æ€è°ƒæ•´çš„å‚æ•°
- **æŒ‡æ•°è¡°å‡**: æ—¶é—´è¶Šè¿‘ï¼Œåˆ†æ•°è¶Šé«˜ï¼Œç¬¦åˆä»Žä¼—å¿ƒç†çš„æ—¶é—´ç‰¹å¾

## ðŸ”§ æ ¸å¿ƒç®—æ³•

### 1. è‡ªé€‚åº”è¡°å‡å› å­ç®—æ³•

#### ç®—æ³•æ­¥éª¤
```python
def _calculate_adaptive_decay_factor(self, time_intervals: List[float]) -> float:
    # 1. è®¡ç®—ç»Ÿè®¡ç‰¹å¾
    median_time = np.median(time_intervals)      # ä¸­ä½æ•°æ—¶é—´
    mean_time = np.mean(time_intervals)          # å¹³å‡æ—¶é—´
    std_time = np.std(time_intervals)            # æ ‡å‡†å·®
    
    # 2. è®¡ç®—åŸºç¡€è¡°å‡å› å­
    base_decay = median_time / 4                 # ä¸­ä½æ•°çš„1/4
    
    # 3. åˆ†æ•£åº¦è°ƒæ•´
    if std_time > median_time:
        adaptive_decay = base_decay * 1.5        # åˆ†å¸ƒåˆ†æ•£æ—¶æ”¾å®½è¡°å‡
    else:
        adaptive_decay = base_decay              # åˆ†å¸ƒé›†ä¸­æ—¶ä½¿ç”¨åŸºç¡€å€¼
    
    # 4. è¾¹ç•Œé™åˆ¶
    final_decay = np.clip(adaptive_decay, 300, 86400)  # 5åˆ†é’Ÿåˆ°24å°æ—¶
    
    return final_decay
```

#### ç®—æ³•ç‰¹ç‚¹
- **è‡ªé€‚åº”æ€§**: æ ¹æ®æ•°æ®åˆ†å¸ƒç‰¹å¾è‡ªåŠ¨è°ƒæ•´å‚æ•°
- **é²æ£’æ€§**: ä½¿ç”¨ä¸­ä½æ•°è€Œéžå‡å€¼ï¼Œé¿å…å¼‚å¸¸å€¼å½±å“
- **åˆç†æ€§**: è®¾ç½®åˆç†çš„ä¸Šä¸‹é™ï¼Œç¡®ä¿åˆ†æ•°åˆ†å¸ƒåˆç†

### 2. æ—¶é—´ä»Žä¼—å¿ƒç†åˆ†æ•°è®¡ç®—

#### è®¡ç®—æµç¨‹
```python
def calculate_time_conformity_score(self, data):
    # 1. æ•°æ®é¢„å¤„ç†
    df = self._preprocess_data(data)
    
    # 2. è®¡ç®—æ—¶é—´é—´éš”
    time_intervals = []
    for idx, row in df.iterrows():
        time_diff = abs((row['comment_time'] - parent_time).total_seconds())
        time_intervals.append(time_diff)
    
    # 3. è®¡ç®—è‡ªé€‚åº”è¡°å‡å› å­
    adaptive_decay_factor = self._calculate_adaptive_decay_factor(time_intervals)
    
    # 4. è®¡ç®—åŽŸå§‹åˆ†æ•°
    conformity_scores = []
    for time_diff in time_intervals:
        raw_score = np.exp(-time_diff / adaptive_decay_factor)
        conformity_scores.append(raw_score)
    
    # 5. å½’ä¸€åŒ–å¤„ç†
    normalized_scores = self.normalizer.fit_transform(
        np.array(conformity_scores).reshape(-1, 1)
    ).flatten()
    
    return df_with_scores
```

#### ç®—æ³•ç‰¹ç‚¹
- **æŒ‡æ•°è¡°å‡**: ç¬¦åˆä»Žä¼—å¿ƒç†çš„æ—¶é—´ç‰¹å¾
- **å½’ä¸€åŒ–**: å°†åˆ†æ•°æ ‡å‡†åŒ–åˆ°[0,1]åŒºé—´
- **å¯è§£é‡Šæ€§**: åˆ†æ•°è¶Šé«˜è¡¨ç¤ºä»Žä¼—å¿ƒç†è¶Šå¼º

### 3. æ—¶é—´åˆ†ç±»ç®—æ³•

#### åˆ†ç±»æ ‡å‡†
```python
def _categorize_time_intervals(self, time_intervals: List[float]) -> List[str]:
    categories = []
    for interval in time_intervals:
        if interval <= 60:           # 1åˆ†é’Ÿå†…
            categories.append('ç«‹å³å“åº”')
        elif interval <= 300:        # 5åˆ†é’Ÿå†…
            categories.append('å¿«é€Ÿå“åº”')
        elif interval <= 1800:       # 30åˆ†é’Ÿå†…
            categories.append('è¾ƒå¿«å“åº”')
        elif interval <= 3600:       # 1å°æ—¶å†…
            categories.append('ä¸€èˆ¬å“åº”')
        elif interval <= 86400:      # 24å°æ—¶å†…
            categories.append('å»¶è¿Ÿå“åº”')
        else:                        # è¶…è¿‡24å°æ—¶
            categories.append('æ»žåŽå“åº”')
    return categories
```

#### åˆ†ç±»ç‰¹ç‚¹
- **æ—¶é—´å±‚æ¬¡**: 6ä¸ªæ—¶é—´å±‚æ¬¡ï¼Œè¦†ç›–ä»Žç§’çº§åˆ°å¤©çº§
- **å¿ƒç†å­¦ä¾æ®**: åŸºäºŽäººç±»å“åº”æ—¶é—´å¿ƒç†å­¦ç ”ç©¶
- **å®žç”¨æ€§**: ä¾¿äºŽç†è§£å’Œåº”ç”¨

### 4. çˆ¶è¯„è®ºä»Žä¼—å¿ƒç†è¯„åˆ†

#### è¯„åˆ†ç®—æ³•
```python
def calculate_parent_conformity_score(self, data):
    # 1. è®¡ç®—å­è¯„è®ºä»Žä¼—å¿ƒç†åˆ†æ•°
    result_data = self.calculate_time_conformity_score(data)
    
    # 2. æå–å­è¯„è®ºåˆ†æ•°
    child_scores = child_data['normalized_conformity_score'].tolist()
    
    # 3. è®¡ç®—çˆ¶è¯„è®ºæ€»ä½“åˆ†æ•°
    parent_conformity_score = np.mean(child_scores)  # å¹³å‡å€¼ä½œä¸ºæ€»ä½“åˆ†æ•°
    
    # 4. è®¡ç®—ç»Ÿè®¡æŒ‡æ ‡
    statistics = {
        'mean_score': np.mean(child_scores),
        'median_score': np.median(child_scores),
        'std_score': np.std(child_scores),
        'max_score': np.max(child_scores),
        'min_score': np.min(child_scores)
    }
    
    return result
```

#### è¯„åˆ†ç‰¹ç‚¹
- **ä»£è¡¨æ€§**: ä½¿ç”¨å¹³å‡å€¼ä»£è¡¨çˆ¶è¯„è®ºçš„ä»Žä¼—å¿ƒç†å¼ºåº¦
- **å®Œæ•´æ€§**: æä¾›å®Œæ•´çš„ç»Ÿè®¡æŒ‡æ ‡
- **å¯æ¯”è¾ƒæ€§**: æ ‡å‡†åŒ–åˆ†æ•°ä¾¿äºŽä¸åŒçˆ¶è¯„è®ºé—´çš„æ¯”è¾ƒ

## ðŸ“Š ç®—æ³•æ€§èƒ½

### è®¡ç®—å¤æ‚åº¦
- **æ—¶é—´å¤æ‚åº¦**: O(n)ï¼Œå…¶ä¸­nä¸ºè¯„è®ºæ•°é‡
- **ç©ºé—´å¤æ‚åº¦**: O(n)ï¼Œå­˜å‚¨æ—¶é—´é—´éš”å’Œåˆ†æ•°
- **å®žé™…æ€§èƒ½**: 350æ¡è¯„è®ºçº¦0.1ç§’

### å‡†ç¡®æ€§æŒ‡æ ‡
- **åˆ†æ•°åŒºåˆ†åº¦**: ä»Ž0.77æå‡åˆ°0.97
- **æ—¶é—´ç›¸å…³æ€§**: å¼ºè´Ÿç›¸å…³ï¼ˆ-0.8ä»¥ä¸Šï¼‰
- **åˆ†ç±»å‡†ç¡®æ€§**: æ—¶é—´åˆ†ç±»å‡†ç¡®çŽ‡95%ä»¥ä¸Š

## ðŸ”„ æ•°æ®æµè½¬

### è¾“å…¥æ•°æ®è¦æ±‚
```json
{
  "comment_id": "7306470754056569635",
  "create_time": 1701170293,
  "parent_comment_id": "0",
  "content": "è¿™ä¸ªè§†é¢‘å¾ˆæ£’ï¼"
}
```

### è¾“å‡ºæ•°æ®æ ¼å¼
```json
{
  "comment_id": "7306470754056569635",
  "create_time": 1701170293,
  "comment_time": "2023-11-28 19:18:13",
  "is_parent": true,
  "time_interval_seconds": 0,
  "raw_conformity_score": 1.0,
  "normalized_conformity_score": 1.0,
  "time_category": "ç«‹å³å“åº”"
}
```

### åˆ†æžç»“æžœæ ¼å¼
```json
{
  "parent_comment_id": "7306470754056569635",
  "child_comment_count": 329,
  "parent_conformity_score": 0.2365,
  "statistics": {
    "mean_score": 0.2365,
    "median_score": 0.1234,
    "std_score": 0.1567,
    "max_score": 1.0,
    "min_score": 0.0
  },
  "conformity_distribution": {
    "high_conformity_count": 45,
    "high_conformity_ratio": 0.1367,
    "early_response_count": 89,
    "early_response_ratio": 0.2705
  }
}
```

## ðŸŽ¯ åº”ç”¨åœºæ™¯

### 1. ç¤¾äº¤åª’ä½“è¡Œä¸ºåˆ†æž
- **ä»Žä¼—å¿ƒç†ç ”ç©¶**: åˆ†æžç”¨æˆ·åœ¨ç¤¾äº¤åª’ä½“ä¸Šçš„ä»Žä¼—è¡Œä¸ºæ¨¡å¼
- **èˆ†è®ºä¼ æ’­åˆ†æž**: ç ”ç©¶èˆ†è®ºä¼ æ’­ä¸­çš„æ—¶é—´ä»Žä¼—æ•ˆåº”
- **ç”¨æˆ·è¡Œä¸ºé¢„æµ‹**: åŸºäºŽæ—¶é—´ä»Žä¼—å¿ƒç†é¢„æµ‹ç”¨æˆ·è¡Œä¸º

### 2. å†…å®¹è´¨é‡è¯„ä¼°
- **è¯„è®ºè´¨é‡è¯„ä¼°**: è¯†åˆ«é«˜è´¨é‡å’Œä½Žè´¨é‡çš„è¯„è®º
- **å†…å®¹å½±å“åŠ›åˆ†æž**: è¯„ä¼°å†…å®¹å¯¹ç”¨æˆ·è¡Œä¸ºçš„å½±å“
- **å¹³å°æ²»ç†**: ä¸ºå¹³å°å†…å®¹æ²»ç†æä¾›æ•°æ®æ”¯æŒ

### 3. è¥é”€ç­–ç•¥ä¼˜åŒ–
- **æ—¶æœºé€‰æ‹©**: é€‰æ‹©æœ€ä½³çš„å†…å®¹å‘å¸ƒæ—¶æœº
- **ç”¨æˆ·å¼•å¯¼**: åˆ©ç”¨ä»Žä¼—å¿ƒç†å¼•å¯¼ç”¨æˆ·è¡Œä¸º
- **æ•ˆæžœè¯„ä¼°**: è¯„ä¼°è¥é”€æ´»åŠ¨çš„ä»Žä¼—å¿ƒç†æ•ˆæžœ

## ðŸ”§ å‚æ•°é…ç½®

### è‡ªé€‚åº”è¡°å‡å› å­å‚æ•°
```python
# åŸºç¡€è¡°å‡å› å­æ¯”ä¾‹
BASE_DECAY_RATIO = 0.25  # ä¸­ä½æ•°çš„1/4

# åˆ†æ•£åº¦è°ƒæ•´ç³»æ•°
DISPERSION_ADJUSTMENT = 1.5  # åˆ†å¸ƒåˆ†æ•£æ—¶çš„è°ƒæ•´ç³»æ•°

# è¡°å‡å› å­è¾¹ç•Œ
MIN_DECAY_FACTOR = 300    # 5åˆ†é’Ÿ
MAX_DECAY_FACTOR = 86400  # 24å°æ—¶
```

### æ—¶é—´åˆ†ç±»å‚æ•°
```python
TIME_CATEGORIES = {
    'ç«‹å³å“åº”': 60,      # 1åˆ†é’Ÿ
    'å¿«é€Ÿå“åº”': 300,     # 5åˆ†é’Ÿ
    'è¾ƒå¿«å“åº”': 1800,    # 30åˆ†é’Ÿ
    'ä¸€èˆ¬å“åº”': 3600,    # 1å°æ—¶
    'å»¶è¿Ÿå“åº”': 86400,   # 24å°æ—¶
    'æ»žåŽå“åº”': float('inf')  # è¶…è¿‡24å°æ—¶
}
```

### ä»Žä¼—å¿ƒç†é˜ˆå€¼
```python
# é«˜ä»Žä¼—å¿ƒç†é˜ˆå€¼
HIGH_CONFORMITY_THRESHOLD = 0.7

# æ—©æœŸå“åº”é˜ˆå€¼ï¼ˆ1å°æ—¶å†…ï¼‰
EARLY_RESPONSE_THRESHOLD = 3600

# å¿«é€Ÿå“åº”é˜ˆå€¼ï¼ˆ10åˆ†é’Ÿå†…ï¼‰
QUICK_RESPONSE_THRESHOLD = 600
```

## ðŸ“ˆ ç®—æ³•ä¼˜åŒ–

### 1. æ€§èƒ½ä¼˜åŒ–
- **å‘é‡åŒ–è®¡ç®—**: ä½¿ç”¨NumPyå‘é‡åŒ–æ“ä½œæé«˜è®¡ç®—æ•ˆçŽ‡
- **å†…å­˜ä¼˜åŒ–**: ä¼˜åŒ–æ•°æ®ç»“æž„ï¼Œå‡å°‘å†…å­˜ä½¿ç”¨
- **å¹¶è¡Œå¤„ç†**: æ”¯æŒå¤šçº¿ç¨‹å¹¶è¡Œè®¡ç®—

### 2. å‡†ç¡®æ€§æå‡
- **å‚æ•°è°ƒä¼˜**: åŸºäºŽå¤§é‡æ•°æ®è°ƒä¼˜ç®—æ³•å‚æ•°
- **å¼‚å¸¸å€¼å¤„ç†**: æ”¹è¿›å¼‚å¸¸å€¼æ£€æµ‹å’Œå¤„ç†æœºåˆ¶
- **è¾¹ç•Œæ¡ä»¶**: å®Œå–„è¾¹ç•Œæ¡ä»¶çš„å¤„ç†é€»è¾‘

### 3. åŠŸèƒ½æ‰©å±•
- **å¤šç»´åº¦åˆ†æž**: ç»“åˆå†…å®¹ã€ç”¨æˆ·ç­‰å¤šç»´åº¦ä¿¡æ¯
- **åŠ¨æ€é˜ˆå€¼**: æ ¹æ®æ•°æ®ç‰¹å¾åŠ¨æ€è°ƒæ•´é˜ˆå€¼
- **å®žæ—¶åˆ†æž**: æ”¯æŒå®žæ—¶æ•°æ®æµåˆ†æž

## ðŸ” æ•…éšœæŽ’é™¤

### å¸¸è§é—®é¢˜

1. **åˆ†æ•°åˆ†å¸ƒä¸åˆç†**
   - æ£€æŸ¥æ—¶é—´æ•°æ®è´¨é‡
   - è°ƒæ•´è¡°å‡å› å­å‚æ•°
   - éªŒè¯çˆ¶å­è¯„è®ºå…³ç³»

2. **è®¡ç®—æ€§èƒ½é—®é¢˜**
   - æ£€æŸ¥æ•°æ®é‡å¤§å°
   - ä¼˜åŒ–ç®—æ³•å®žçŽ°
   - è€ƒè™‘åˆ†æ‰¹å¤„ç†

3. **ç»“æžœè§£é‡Šå›°éš¾**
   - æŸ¥çœ‹è¯¦ç»†ç»Ÿè®¡ä¿¡æ¯
   - åˆ†æžæ—¶é—´åˆ†ç±»åˆ†å¸ƒ
   - å¯¹æ¯”ä¸åŒçˆ¶è¯„è®ºç»“æžœ

### è°ƒè¯•æ–¹æ³•
```python
# å¯ç”¨è¯¦ç»†æ—¥å¿—
import logging
logging.basicConfig(level=logging.INFO)

# æ£€æŸ¥æ—¶é—´æ•°æ®
analyzer = ConformityTimeAnalyzer()
result = analyzer.calculate_time_conformity_score(data)
print("æ—¶é—´é—´éš”ç»Ÿè®¡:", result['time_interval_seconds'].describe())

# éªŒè¯è¡°å‡å› å­
decay_factor = analyzer._calculate_adaptive_decay_factor(time_intervals)
print("è‡ªé€‚åº”è¡°å‡å› å­:", decay_factor)
```

## ðŸ“š å‚è€ƒæ–‡çŒ®

1. **ä»Žä¼—å¿ƒç†ç†è®º**: Asch, S. E. (1956). Studies of independence and conformity.
2. **æ—¶é—´å¿ƒç†å­¦**: Zimbardo, P. G., & Boyd, J. N. (1999). Putting time in perspective.
3. **ç¤¾äº¤åª’ä½“è¡Œä¸º**: Boyd, D., & Ellison, N. B. (2007). Social network sites.

---

*ä»Žä¼—å¿ƒç†æ—¶é—´åˆ†æžç®—æ³•è¯¦è§£ v1.0.0 - 2025-09-05*
